import Optional from './types/Optional';
import ItemData from './types/ItemData';
import ObjectLiteral from './types/ObjectLiteral';
import ID from './types/ID';
declare const add: <T extends ItemData<{
    id: ID;
}>>(items: T[], data: Optional<T, "depth"> | Optional<T, "depth">[]) => T[];
declare const insert: <T extends ItemData<{
    id: ID;
}>>(items: T[], data: Optional<T, "depth"> | Optional<T, "depth">[], targetIndex: number) => T[];
declare const remove: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number) => T[];
/**
 * @hidden
 */
declare const memoizedFindDescendants: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number) => T[];
/**
 * @hidden
 */
declare const memoizedFindDeepestDescendant: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number) => T | null;
/**
 * @hidden
 */
declare const memoizedFindParent: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number) => T | null;
/**
 * @hidden
 */
declare const memoizedFindNextSibling: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number) => T | null;
/**
 * @hidden
 */
declare const memoizedFindPrevSibling: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number) => T | null;
/**
 * @hidden
 */
declare const memoizedIsNextSibling: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number, siblingIndex: number) => boolean;
/**
 * @hidden
 */
declare const memoizedIsPrevSibling: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number, siblingIndex: number) => boolean;
/**
 * @hidden
 */
declare const memoizedIsClosestOf: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number, descendantIndex: number) => boolean;
/**
 * @hidden
 */
declare const memoizedIsDescendantOf: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number, closestIndex: number) => boolean;
/**
 * @hidden
 */
declare const memoizedMove: <T extends ItemData<{
    id: ID;
}>>(items: T[], sourceIndex: number, targetIndex: number) => T[];
/**
 * @hidden
 */
declare const memoizedUpdateDepth: <T extends ItemData<{
    id: ID;
}>>(items: T[], index: number, depth: number, maxDepth?: number) => T[];
/**
 * @hidden
 */
declare const memoizedConvert: <T extends ObjectLiteral & {
    id: ID;
    parentId?: string | number | null | undefined;
    index: number;
}>(items: T[], parentId?: string | number | null | undefined, depth?: number | undefined) => ItemData<T>[];
/**
 * @hidden
 */
declare const memoizedBuildTree: <T extends ObjectLiteral>(items: ItemData<T>[], depth?: number) => (T & {
    children: T[];
})[];
/**
 * @hidden
 */
declare const memoizedFlatten: <T extends ItemData<{
    id: ID;
}>>(items: T[]) => (Pick<T, Exclude<keyof T, "depth">> & {
    index: number;
    parentId: ID;
})[];
export { memoizedFindDescendants as findDescendants, memoizedFindDeepestDescendant as findDeepestDescendant, memoizedFindParent as findParent, memoizedFindNextSibling as findNextSibling, memoizedFindPrevSibling as findPrevSibling, memoizedIsNextSibling as isNextSibling, memoizedIsPrevSibling as isPrevSibling, memoizedIsClosestOf as isClosestOf, memoizedIsDescendantOf as isDescendantOf, memoizedMove as move, memoizedUpdateDepth as updateDepth, add, insert, remove, memoizedConvert as convert, memoizedBuildTree as buildTree, memoizedFlatten as flatten, };

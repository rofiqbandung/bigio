"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const immutability_helper_1 = __importDefault(require("immutability-helper"));
const utils_1 = require("./utils");
const useAnimationFrame_1 = __importDefault(require("./useAnimationFrame"));
const context_1 = __importDefault(require("./context"));
const sortlyContext_1 = __importDefault(require("./sortlyContext"));
const itemContext_1 = __importDefault(require("./itemContext"));
const Item_1 = __importDefault(require("./Item"));
/**
 * @hidden
 */
const isRef = (obj) => (
// eslint-disable-next-line no-prototype-builtins
obj !== null && typeof obj === 'object' && obj.hasOwnProperty('current'));
/**
 * @hidden
 */
const getElConnectableElement = (connectedDropTarget) => {
    if (!connectedDropTarget) {
        return null;
    }
    const connectable = connectedDropTarget.current || connectedDropTarget;
    if (!connectable) {
        return null;
    }
    const el = isRef(connectable)
        ? (connectable.current) : connectable;
    return el;
};
/**
 * @hidden
 */
const detectMove = (items, dragMonitor, dragId, targetId, dropEl, horizontal) => {
    const pointerOffset = dragMonitor.getClientOffset();
    if (!pointerOffset) {
        return items;
    }
    const targetBoundingRect = dropEl.getBoundingClientRect();
    const sourceIndex = items.findIndex(({ id }) => id === dragId);
    const targetIndex = items.findIndex(({ id }) => id === targetId);
    if (sourceIndex === -1 || targetIndex === -1) {
        return items;
    }
    if (!horizontal) {
        const hoverMiddleY = (targetBoundingRect.bottom - targetBoundingRect.top) / 2;
        const hoverClientY = pointerOffset.y - targetBoundingRect.top;
        if ((hoverClientY < hoverMiddleY && utils_1.isNextSibling(items, sourceIndex, targetIndex)) // Dragging downwards
            || (hoverClientY > hoverMiddleY && utils_1.isPrevSibling(items, sourceIndex, targetIndex)) // Dragging upwards
        ) {
            return items;
        }
    }
    else {
        const hoverMiddleX = (targetBoundingRect.right - targetBoundingRect.left) / 2;
        const hoverClientX = pointerOffset.x - targetBoundingRect.left;
        if ((hoverClientX < hoverMiddleX && utils_1.isNextSibling(items, sourceIndex, targetIndex)) // Dragging forwards
            || (hoverClientX > hoverMiddleX && utils_1.isPrevSibling(items, sourceIndex, targetIndex)) // Dragging backwards
        ) {
            return items;
        }
    }
    return utils_1.move(items, sourceIndex, targetIndex);
};
/**
 * @hidden
 */
const detectIndent = (items, dragMonitor, dragId, dragEl, threshold, initialDepth, maxDepth) => {
    if (maxDepth === 0) {
        return items;
    }
    const sourceClientOffset = dragMonitor.getSourceClientOffset();
    if (!sourceClientOffset) {
        return items;
    }
    const boundingRect = dragEl.getBoundingClientRect();
    const movementX = sourceClientOffset.x - boundingRect.left;
    if (Math.abs(movementX) < threshold) {
        return items;
    }
    const index = items.findIndex(({ id }) => id === dragId);
    if (index === -1) {
        return items;
    }
    const item = items[index];
    const depth = item.depth + (movementX > 0 ? 1 : -1);
    return utils_1.updateDepth(items, index, depth, maxDepth);
};
/**
 * @hidden
 */
const typeSeq = (() => {
    let seq = 0;
    return () => {
        seq += 1;
        return `SORTLY-${seq}`;
    };
})();
function Sortly(props) {
    const { type: typeFromProps, items, children, threshold = 20, maxDepth = Infinity, horizontal, onChange } = props;
    const [type, setType] = react_1.default.useState(typeFromProps || typeSeq());
    react_1.default.useEffect(() => {
        if (typeFromProps) {
            setType(typeFromProps);
        }
    }, [typeFromProps]);
    const { dragMonitor, connectedDragSource, initialDepth } = react_1.default.useContext(context_1.default);
    const dndData = react_1.default.useRef({});
    const [startAnim, stopAnim] = useAnimationFrame_1.default(react_1.default.useCallback(() => {
        const { dropTargetId, connectedDropTarget } = dndData.current;
        if (!dragMonitor) {
            return;
        }
        const dragItem = dragMonitor.getItem();
        if (!dragItem) {
            return;
        }
        const { id: dragId } = dragItem;
        let newItems;
        if (!dropTargetId || dragId === dropTargetId) {
            const el = getElConnectableElement(connectedDragSource);
            if (initialDepth !== undefined && el) {
                newItems = detectIndent(items, dragMonitor, dragId, el, threshold, initialDepth, maxDepth);
            }
        }
        else if (connectedDropTarget) {
            const dropElement = getElConnectableElement(connectedDropTarget);
            if (dropElement) {
                newItems = detectMove(items, dragMonitor, dragId, dropTargetId, dropElement, horizontal);
            }
        }
        if (newItems && newItems !== items) {
            onChange(newItems);
        }
    }, [connectedDragSource, dragMonitor, horizontal, initialDepth, items, maxDepth, onChange, threshold]));
    const handleHoverBegin = react_1.default.useCallback((id, connectedDropTarget) => {
        dndData.current = immutability_helper_1.default(dndData.current, {
            dropTargetId: { $set: id }, connectedDropTarget: { $set: connectedDropTarget }
        });
    }, []);
    const handleHoverEnd = react_1.default.useCallback((id) => {
        if (dndData.current.dropTargetId === id) {
            dndData.current = immutability_helper_1.default(dndData.current, {
                dropTargetId: { $set: undefined }, connectedDropTarget: { $set: undefined }
            });
        }
    }, []);
    react_1.default.useEffect(() => {
        if (dragMonitor) {
            startAnim();
        }
        else {
            stopAnim();
        }
        return () => {
            stopAnim();
        };
    }, [dragMonitor, startAnim, stopAnim]);
    return (react_1.default.createElement(sortlyContext_1.default.Provider, { value: { items } }, items.map((data, index) => (react_1.default.createElement(itemContext_1.default.Provider, { key: data.id, value: {
            index,
            id: data.id,
            type,
            depth: data.depth,
            data,
            onHoverBegin: handleHoverBegin,
            onHoverEnd: handleHoverEnd,
        } },
        react_1.default.createElement(Item_1.default, { index: index, id: data.id, depth: data.depth, data: data }, children))))));
}
exports.default = Sortly;

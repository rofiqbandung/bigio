"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const react_dnd_1 = require("react-dnd");
const context_1 = __importDefault(require("./context"));
const itemContext_1 = __importDefault(require("./itemContext"));
function useDrag(
// @ts-ignore
spec) {
    const connectedDragRef = react_1.default.useRef();
    const { setDragMonitor, setConnectedDragSource, setInitialDepth } = react_1.default.useContext(context_1.default);
    const { id, type, depth } = react_1.default.useContext(itemContext_1.default);
    const [collectedProps, originalDonnectDragSource, connectDragPreview] = react_dnd_1.useDrag(Object.assign(Object.assign({}, spec), { collect: (monitor) => {
            const $isDragging = monitor.isDragging();
            return Object.assign(Object.assign({}, (spec && spec.collect ? spec.collect(monitor) : undefined)), { $isDragging });
        }, isDragging: (monitor) => monitor.getItem().id === id, item: Object.assign(Object.assign({ type }, (spec && spec.item ? spec.item : {})), { id }), begin(monitor) {
            setInitialDepth(depth);
            setDragMonitor(monitor);
            if (spec && spec.begin) {
                const result = spec.begin(monitor);
                if (typeof result === 'object') {
                    return Object.assign(Object.assign({ type }, result), { id });
                }
            }
            return undefined;
        },
        end(...args) {
            setInitialDepth(undefined);
            setDragMonitor(undefined);
            if (spec && spec.end) {
                spec.end(...args);
            }
        } }));
    const connectDragSource = (...args) => {
        const result = originalDonnectDragSource(...args);
        // @ts-ignore
        connectedDragRef.current = result;
        return result;
    };
    const { $isDragging } = collectedProps, rest = __rest(collectedProps, ["$isDragging"]);
    react_1.default.useEffect(() => {
        if ($isDragging) {
            setConnectedDragSource(connectedDragRef);
        }
    }, [$isDragging, setConnectedDragSource]);
    return [
        // @ts-ignore
        rest,
        connectDragSource,
        connectDragPreview,
    ];
}
exports.default = useDrag;
